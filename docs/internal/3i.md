# 3i and Grates

## ThreeI

3i (Three-I) provides a general means for cages (and grates) to make system calls and intercept system calls via a programmable system call table.  The goal is to enable complex functionality without modifying the microvisor or increasing the microvisor's trusted computing base. 

### Motivation

In a traditional Linux environment, extending or intercepting system calls (e.g., adding a new filesystem, tracing, or filtering calls) requires kernel modifications or mechanisms such as ptrace, which incur heavy overhead and depend on kernel-level mediation.

3i eliminates these constraints by introducing a user-space routing layer between cages, grates, and the underlying microvisor. Calls can be dispatched directly between grates or delegated to the microvisor when necessary, achieving kernel-level extensibility while keeping all new logic external to the kernel’s TCB.

### High-level Concepts

In traditional operating systems, a process makes a system call which traps into the kernel.  Every process which makes a system call ends up trapping into the same kernel routine.  In essence, there is one system call table which is shared by every process.

In contrast, in Lind, 3i provides a per-cage system call table.  A cage can write a function that is a system call handler (or handler, for short) and then register a handler ( register_handler ) for a specific system call of a cage (security will be discussed later).  Whenever that cage makes a system call ( make_syscall ), it ends up calling that function.  Since every cage has its own system call table, the handlers for different cages may vary.

As a term of convenience, we call a cage which processes system calls a "grate".  This is meant to convey the mental model of a cage calling down towards the microvisor / kernel and having a grate filter or transform or handle those system calls.  However, a grate is simply a cage and there is no special handling code or permission for it in 3i or the rest of the system.  A grate may tend to make different system calls from a normal application, but it is still a cage, much like strace is still a normal Linux process that happens to use system calls like ptrace which are otherwise rare.

One important feature needed by a grate is the ability to read and write the memory of a cage which makes a system call it intercepts.  For example, to handle a write system call, the grate must be able to read data out of the calling cage's buffer, which involves reading the calling cage's memory.  3i provides a function ( copy_data_between_cages ) to enable this feature safely.  

Let's consider a special case for a moment, that of a grate that wants to count the number of times the write system call is called.  This grate wants to increment a counter and then make the cage's write system call using the grate's own system call table.  If the cage is writing large amounts of data, copying this information would be extremely wasteful given that the grate does not care about its contents or need to read it.  Hence, make_syscall enables different arguments to a syscall to come from different cages.  This means that the grate can execute the write system call and indicate that the pointer to the write buffer is in the cage's address space.  This ability to specify arguments that live in different address spaces is needed across a variety of grates and so 3i's make_syscall function supports specifying a cageid per argument.

One final important feature of make_syscall is the necessity for a grate to perform a system call as though another cage was performing it.  Think for the moment about the fork system call.  If a cage calls fork and the grate simply makes a fork call, then the grate itself would be forked instead of the calling cage.  To avoid this, each make_syscall has the ability to specify which cage is the target of the system call.  

Note that the 3i functions mentioned above are themselves just system calls.  So, for example, a grate can intercept the register_handler calls of another grate.  This is the key mechanism that is used to provide security in 3i -- the ability to make a grate that can correctly namespace and enforce protections between cages, including calls to 3i.

### 3i Function Calls 

|           Caller           |       Callee     |           Function            |  Interposable | Remarks |
|----------------------------|------------------|-------------------------------|---------------|---------------|
|           grate            |         3i       | `register_handler`            |      Yes      |Register a handler for a syscall|
|           grate            |         3i       | `copy_handler_table_to_cage`  |      Yes      |Overwrites the entire syscall handler table of a cage|
|           grate            |         3i       | `copy_data_between_cages`     |      Yes      |Copies memory across cages|
|           grate            |         3i       | `make_syscall`                |      No       |Call the registered handler for a syscall|
|   WASM / NaCl / RawPOSIX   |         3i       | `trigger_harsh_cage_exit`     |      No       |Kill a cage: See detailed explaination below|
|         3i / grate         | grate / RawPOSIX | `harsh_cage_exit`             |      Yes      |Notify a cage was killed: See detailed explaination below|

*NOTE: Interposable in the table means whether these calls are made via the system call table and thus whether or not a grate could alter their behavior*

#### `trigger_harsh_cage_exit` and `harsh_cage_exit`  

This is essentially a way for grates to clean up if a cage was abruptly killed (perhaps due to a signal).  `trigger_harsh_cage_exit` is triggered by the caging or signaling infrastructure to indicate that a cage will (uncleanly) exit. After receiving notification, 3i will cleanup the 3i data structure (which is the system call table) and then 3i will go through the respective grates until reaching 3i's version of the call by triggering `harsh_cage_exit`. This call can be thought of as notifying the grates and microvisor of the harsh exit of a program whose memory state cannot be relied upon. This is unlike the `exit_syscall`, which is performed by a functioning program with intact memory as part of its termination.

**Why not interposable?**
At the time `trigger_harsh_cage_exit` or `harsh_cage_exit` is invoked, the target Cage or Grate is assumed to have unreliable memory and control flow. During the execution of these calls, the syscall table of the target cage/grate is either being torn down or may already be corrupted, meaning the call path itself is no longer trustworthy.

The cleanup process must complete system-level invariants such as: unmapping vmmap regions, cleaning fdtables, waking waiters, canceling schedulers or timers, etc.. Allowing these calls to be interposable would permit third-party grates to inject arbitrary logic (e.g., blocking, allocation, or reentrancy), which could stall or disrupt the teardown sequence, resulting in resource leaks, deadlocks, or zombie cages/grates.

## Grates

### Overview

Grates are cages that provide services to descendant cages by interposing on their system calls. They can execute trusted operations (e.g., syscall filtering, tracing, or in-memory file I/O) on behalf of other cages without requiring changes to the microvisor’s trusted computing base (TCB).

From 3i’s perspective, a grate is both:

- A consumer of system calls from descendant cages, and
- A service provider exposing its own callable entry points to the 3i runtime.

### Design Goals

3i’s public API is runtime-agnostic, allowing it to be adapted to multiple backends (e.g., Wasmtime, MPK, or future runtimes).

Runtime-specific mechanisms, such as Wasmtime’s `VMContext` management, are implemented in the corresponding runtime layer (e.g., the Wasmtime adapter). These runtime hooks are exposed to 3i as C-ABI function pointers and registered in 3i’s global table, decoupling runtime details from 3i’s core logic.

### Wasm Implementation

Grate execution relies on a re-entry mechanism that bridges Wasm runtime contexts (e.g., Wasmtime instances) and 3i’s routing layer. 

Each Wasm module in Wasmtime has its own `VMContext`, which encapsulates all runtime state required for that instance’s execution. When 3i performs a cross-module call (e.g., from _cage A_ to a _grate B_), the currently executing context belongs to _A_, but 3i needs to restore the latest runtime state of _B_ before re-entering its Wasm code. 

Because Rust’s lifetime system prevents us from directly sharing or globally storing references to the caller’s runtime structures, we instead store and pass raw pointers to the target module’s `VMContext`. 3i uses a registered callback function pointer and retrived the corresponding runtime context (`VMContext`) from pointer to re-enter the target Wasm instance. This allows 3i to reconstruct the correct execution environment for _B_ at re-entry time, ensuring cross-instance transitions without violating Rust’s ownership and lifetime rules.

During module initialization, Wasmtime captures each instance’s low-level `VMContext`, representing its active execution state (memories, globals, tables, etc.). However, the registration of interposition handlers (`register_handler`) often occurs after initialization. To bridge this timing gap, Wasmtime maintains a runtime-local table:

```rust
GRATE_FN_WASM_TABLE: HashMap<(u64, u64), Box<GrateFnEntry>>
```

- Key: `(cageid, tid)` -- cage and its thread identifiers
- Value: `Box<GrateFnEntry>` -- stable heap-allocated entry containing callback and necessary context pointers

When the user’s Wasm code calls `register_handler`, the entry is extracted and passed to 3i, where it becomes the canonical reference for that `(cageid, tid)` pair.

_Note: `tid = 0` is currently used as a placeholder; multi-thread support will be added in future revisions._

#### Core Data Structures

**`VmCtxWrapper`**

A minimal wrapper around a non-null pointer to a Wasmtime `VMContext`. It allows the context pointer to be passed between Wasmtime and 3i without exposing the raw pointer across the codebase.

**`WasmCallbackCtx`**

Represents a single cage or grate execution context, storing:

- The cage identifier (cageid)
- The wrapped `VMContext` pointer

Each `WasmCallbackCtx` instance corresponds to one runtime environment capable of re-entering the correct Wasm instance during cross-cage invocation.

**`GrateFnEntry`**

Represents a single Grate function entry shared between the lind-3i crate in wasmtime and 3i.

|   Field      |         Type       |                             FunDescriptionction                                   | 
|--------------|--------------------|-----------------------------------------------------------------------------------|
|   `fn_ptr`   |  `*const c_void`   | A C-ABI callback function pointer that re-enters the target Wasm module           |
|   `ctx_ptr`  | `*const VMContext` | Pointer to the instance’s runtime context required by Wasmtime during re-entry    |

`GrateFnEntry` instances are heap-allocated and referenced by 3i through stable raw pointers.

#### Execution Flow

**Callback Definition (Wasmtime side):**

The C-ABI callback function knows how to re-enter the Wasm module via the unified entry function.

**Context Staging:**

Wasmtime captures the instance’s `VMContext` and stores both the callback and context pointers in the `GRATE_FN_WASM_TABLE`.

**Handler Registration:**

1. When the Wasm module calls `register_handler()`, the staging entry is extracted and passed to 3i.
2. 3i associates the provided function/context pair with a specific `(cageid, tid)` in its handler table in 3i.

**Cross-Cage Invocation:**

When a syscall from _cage A_ is routed to _grate B_:

1. the regular syscall reaches 3i via `make_syscall`
2. 3i looks up the `(cageid, tid)` entry for B.
3. 3i retrieves the stored function pointer and `VMContext`.
4. 3i directly invokes the function pointer, re-entering the target Wasm instance through Wasmtime’s runtime context.

**Dispatch Inside Grate:**

The Wasm entry function (in module) receives a pointer identifying the target handler and dispatches control to the correct per-syscall implementation.
