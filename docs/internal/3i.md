# 3i and Grates

## ThreeI

3i (Three-I) provides the inter-cage interposition interface. This is a mechanism through which system calls and other inter-cage calls are routed within the Lind architecture.

It enables **call customization**, **system-call filtering**, and **fine-grained interpostion** without modifying the source code of either the kernel or the microvisor. Each cage and grate maintains its own system call table with customized jump endpoints, allowing flexible interception and redirection of calls at runtime.

### Motivation

In a traditional Linux environment, extending or intercepting system calls (e.g., adding a new filesystem, tracing, or filtering calls) requires kernel modifications or mechanisms such as ptrace, which incur heavy overhead and depend on kernel-level mediation.

3i eliminates these constraints by introducing a user-space routing layer between cages, grates, and the underlying microvisor. Calls can be dispatched directly between grates or delegated to the microvisor when necessary, achieving kernel-level extensibility while keeping all new logic external to the kernel’s TCB.

### 3i Function Calls 

|           Caller           |       Callee     |           Function            |  Interposable | Remarks |
|----------------------------|------------------|-------------------------------|---------------|---------------|
|   WASM / NaCl / RawPOSIX   |         3i       | `trigger_harsh_cage_exit`     |      No       |See detailed explaination below|
|         3i / grate         | grate / RawPOSIX | `harsh_cage_exit`             |      Yes      |See detailed explaination below|
|           grate            |         3i       | `register_handler`            |      Yes      |Register new handler information to syscall table|
|           grate            |         3i       | `copy_handler_table_to_cage`  |      Yes      |Passes the handler table to the target cage|
|           grate            |         3i       | `copy_data_between_cages`     |      Yes      |Copies memory across cages|
|           grate            |         3i       | `make_syscall`                |      No       |Route the call to the corresponding handler and deal with error situations|

*NOTE: Interposable in the table means whether these calls are made via the system call table and thus whether or not a grate could alter their behavior*

#### `trigger_harsh_cage_exit` and `harsh_cage_exit`  

`trigger_harsh_cage_exit` is triggered by the caging or signaling infrastructure to indicate that a cage will (uncleanly) exit. After receiving notification, 3i will cleanup the 3i data structure (which is the system call table) and then 3i will go through the respective grates until reaching 3i's version of the call by triggering `harsh_cage_exit`. This call can be thought of as notifying the grates and microvisor of the harsh exit of a program whose memory state cannot be relied upon. This is unlike the `exit_syscall`, which is performed by a functioning program with intact memory as part of its termination.

**Why not interposable?**
At the time `trigger_harsh_cage_exit` or `harsh_cage_exit` is invoked, the target Cage or Grate is assumed to have unreliable memory and control flow. During the execution of these calls, the syscall table of the target cage/grate is either being torn down or may already be corrupted, meaning the call path itself is no longer trustworthy.

The cleanup process must complete system-level invariants such as: unmapping vmmap regions, cleaning fdtables, waking waiters, canceling schedulers or timers, etc.. Allowing these calls to be interposable would permit third-party grates to inject arbitrary logic (e.g., blocking, allocation, or reentrancy), which could stall or disrupt the teardown sequence, resulting in resource leaks, deadlocks, or zombie cages/grates.

## Grates

### Overview

Grates are cages that provide services to descendant cages by interposing on their system calls. They can execute trusted operations (e.g., syscall filtering, tracing, or in-memory file I/O) on behalf of other cages without requiring changes to the microvisor’s trusted computing base (TCB).

From 3i’s perspective, a grate is both:

- A consumer of system calls from descendant cages, and
- A service provider exposing its own callable entry points to the 3i runtime.

### Design Goals

3i’s public API is runtime-agnostic, allowing it to be adapted to multiple backends (e.g., Wasmtime, MPK, or future runtimes).

Runtime-specific mechanisms, such as Wasmtime’s `VMContext` management, are implemented in the corresponding runtime layer (e.g., the Wasmtime adapter). These runtime hooks are exposed to 3i as C-ABI function pointers and registered in 3i’s global table, decoupling runtime details from 3i’s core logic.

### Wasm Implementation

Grate execution relies on a re-entry mechanism that bridges Wasm runtime contexts (e.g., Wasmtime instances) and 3i’s routing layer. 

Each Wasm module in Wasmtime has its own `VMContext`, which encapsulates all runtime state required for that instance’s execution. When 3i performs a cross-module call (e.g., from _cage A_ to a _grate B_), the currently executing context belongs to _A_, but 3i needs to restore the latest runtime state of _B_ before re-entering its Wasm code. 

Because Rust’s lifetime system prevents us from directly sharing or globally storing references to the caller’s runtime structures, we instead store and pass raw pointers to the target module’s `VMContext`. 3i uses a registered callback function pointer and retrived the corresponding runtime context (`VMContext`) from pointer to re-enter the target Wasm instance. This allows 3i to reconstruct the correct execution environment for _B_ at re-entry time, ensuring cross-instance transitions without violating Rust’s ownership and lifetime rules.

During module initialization, Wasmtime captures each instance’s low-level `VMContext`, representing its active execution state (memories, globals, tables, etc.). However, the registration of interposition handlers (`register_handler`) often occurs after initialization. To bridge this timing gap, Wasmtime maintains a runtime-local table:

```rust
GRATE_FN_WASM_TABLE: HashMap<(u64, u64), Box<GrateFnEntry>>
```

- Key: `(cageid, tid)` -- cage and its thread identifiers
- Value: `Box<GrateFnEntry>` -- stable heap-allocated entry containing callback and necessary context pointers

When the user’s Wasm code calls `register_handler`, the entry is extracted and passed to 3i, where it becomes the canonical reference for that `(cageid, tid)` pair.

_Note: `tid = 0` is currently used as a placeholder; multi-thread support will be added in future revisions._

#### Core Data Structures

**`VmCtxWrapper`**

A minimal wrapper around a non-null pointer to a Wasmtime `VMContext`. It allows the context pointer to be passed between Wasmtime and 3i without exposing the raw pointer across the codebase.

**`WasmCallbackCtx`**

Represents a single cage or grate execution context, storing:

- The cage identifier (cageid)
- The wrapped `VMContext` pointer

Each `WasmCallbackCtx` instance corresponds to one runtime environment capable of re-entering the correct Wasm instance during cross-cage invocation.

**`GrateFnEntry`**

Represents a single Grate function entry shared between the lind-3i crate in wasmtime and 3i.

|   Field      |         Type       |                             FunDescriptionction                                   | 
|--------------|--------------------|-----------------------------------------------------------------------------------|
|   `fn_ptr`   |  `*const c_void`   | A C-ABI callback function pointer that re-enters the target Wasm module           |
|   `ctx_ptr`  | `*const VMContext` | Pointer to the instance’s runtime context required by Wasmtime during re-entry    |

`GrateFnEntry` instances are heap-allocated and referenced by 3i through stable raw pointers.

#### Execution Flow

**Callback Definition (Wasmtime side):**

The C-ABI callback function knows how to re-enter the Wasm module via the unified entry function.

**Context Staging:**

Wasmtime captures the instance’s `VMContext` and stores both the callback and context pointers in the `GRATE_FN_WASM_TABLE`.

**Handler Registration:**

1. When the Wasm module calls `register_handler()`, the staging entry is extracted and passed to 3i.
2. 3i associates the provided function/context pair with a specific `(cageid, tid)` in its handler table in 3i.

**Cross-Cage Invocation:**

When a syscall from _cage A_ is routed to _grate B_:

1. the regular syscall reaches 3i via `make_syscall`
2. 3i looks up the `(cageid, tid)` entry for B.
3. 3i retrieves the stored function pointer and `VMContext`.
4. 3i directly invokes the function pointer, re-entering the target Wasm instance through Wasmtime’s runtime context.

**Dispatch Inside Grate:**

The Wasm entry function (in module) receives a pointer identifying the target handler and dispatches control to the correct per-syscall implementation.
