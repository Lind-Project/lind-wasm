# 3i and Grates

## ThreeI

3i (Three-I) provides a general means for cages (and grates) to make system calls and intercept system calls via a programmable system call table.  The goal is to enable complex functionality without modifying the microvisor or increasing the microvisor's trusted computing base. 

### Motivation

In a traditional Linux environment, extending or intercepting system calls (e.g., adding a new filesystem, tracing, or filtering calls) requires kernel modifications or mechanisms such as ptrace, which incur heavy overhead and depend on kernel-level mediation.

3i eliminates these constraints by introducing a user-space routing layer between cages, grates, and the underlying microvisor. Calls can be dispatched directly between grates or delegated to the microvisor when necessary, achieving kernel-level extensibility while keeping all new logic external to the kernel’s TCB.

### High-level Concepts

In traditional operating systems, a process makes a system call which traps into the kernel.  Every process which makes a system call ends up trapping into the same kernel routine.  In essence, there is one system call table which is shared by every process.

In contrast, in Lind, 3i provides a per-cage system call table.  A cage can write a function that is a system call handler (or handler, for short) and then register a handler ( register_handler ) for a specific system call of a cage (security will be discussed later).  Whenever that cage makes a system call ( make_syscall ), it ends up calling that function.  Since every cage has its own system call table, the handlers for different cages may vary.

As a term of convenience, we call a cage which processes system calls a "grate".  This is meant to convey the mental model of a cage calling down towards the microvisor / kernel and having a grate filter or transform or handle those system calls.  However, a grate is simply a cage and there is no special handling code or permission for it in 3i or the rest of the system.  A grate may tend to make different system calls from a normal application, but it is still a cage, much like strace is still a normal Linux process that happens to use system calls like ptrace which are otherwise rare.

One important feature needed by a grate is the ability to read and write the memory of a cage which makes a system call it intercepts.  For example, to handle a write system call, the grate must be able to read data out of the calling cage's buffer, which involves reading the calling cage's memory.  3i provides a function ( copy_data_between_cages ) to enable this feature safely.  

Let's consider a special case for a moment, that of a grate that wants to count the number of times the write system call is called.  This grate wants to increment a counter and then make the cage's write system call using the grate's own system call table.  If the cage is writing large amounts of data, copying this information would be extremely wasteful given that the grate does not care about its contents or need to read it.  Hence, make_syscall enables different arguments to a syscall to come from different cages.  This means that the grate can execute the write system call and indicate that the pointer to the write buffer is in the cage's address space.  This ability to specify arguments that live in different address spaces is needed across a variety of grates and so 3i's make_syscall function supports specifying a cageid per argument.

One final important feature of make_syscall is the necessity for a grate to perform a system call as though another cage was performing it.  Think for the moment about the fork system call.  If a cage calls fork and the grate simply makes a fork call, then the grate itself would be forked instead of the calling cage.  To avoid this, each make_syscall has the ability to specify which cage is the target of the system call.  

Note that the 3i functions mentioned above are themselves just system calls.  So, for example, a grate can intercept the register_handler calls of another grate.  This is the key mechanism that is used to provide security in 3i -- the ability to make a grate that can correctly namespace and enforce protections between cages, including calls to 3i.

### 3i Function Calls 

|           Caller           |       Callee     |           Function            |  Interposable | Remarks |
|----------------------------|------------------|-------------------------------|---------------|---------------|
|           grate            |         3i       | `register_handler`            |      Yes      |Register a handler for a syscall|
|           grate            |         3i       | `copy_handler_table_to_cage`  |      Yes      |Overwrites the entire syscall handler table of a cage|
|           grate            |         3i       | `copy_data_between_cages`     |      Yes      |Copies memory across cages|
|           grate            |         3i       | `make_syscall`                |      No       |Call the registered handler for a syscall|
|   WASM / NaCl / RawPOSIX   |         3i       | `trigger_harsh_cage_exit`     |      No       |Kill a cage: See detailed explanation below|
|         3i / grate         | grate / RawPOSIX | `harsh_cage_exit`             |      Yes      |Notify a cage was killed: See detailed explaination below|

*NOTE: Interposable in the table means whether these calls are made via the system call table and thus whether or not a grate could alter their behavior*

#### `trigger_harsh_cage_exit` and `harsh_cage_exit`  

This is essentially a way for grates to clean up if a cage was abruptly killed (perhaps due to a signal).  `trigger_harsh_cage_exit` is triggered by the caging or signaling infrastructure to indicate that a cage will (uncleanly) exit. After receiving notification, 3i will cleanup the 3i data structure (which is the system call table) and then 3i will go through the respective grates until reaching 3i's version of the call by triggering `harsh_cage_exit`. This call can be thought of as notifying the grates and microvisor of the harsh exit of a program whose memory state cannot be relied upon. This is unlike the `exit_syscall`, which is performed by a functioning program with intact memory as part of its termination.

**Why not interposable?**
At the time `trigger_harsh_cage_exit` or `harsh_cage_exit` is invoked, the target Cage or Grate is assumed to have unreliable memory and control flow. During the execution of these calls, the syscall table of the target cage/grate is either being torn down or may already be corrupted, meaning the call path itself is no longer trustworthy.

The cleanup process must complete system-level invariants such as: unmapping vmmap regions, cleaning fdtables, waking waiters, canceling schedulers or timers, etc.. Allowing these calls to be interposable would permit third-party grates to inject arbitrary logic (e.g., blocking, allocation, or reentrancy), which could stall or disrupt the teardown sequence, resulting in resource leaks, deadlocks, or zombie cages/grates.

## Grates

### Overview

Grates are cages that provide services to descendant cages by interposing on their system calls. They can execute trusted operations (e.g., syscall filtering, tracing, or in-memory file I/O) on behalf of other cages without requiring changes to the microvisor’s trusted computing base (TCB).

From 3i’s perspective, a grate is both:

- A consumer of system calls from descendant cages, and
- A service provider exposing one or more of its own functions to some set of other cages.

### Design Goals

3i’s API is runtime-agnostic, allowing it to be adapted to different backends (e.g., Wasmtime, MPK, NaCl, or future runtimes) and also supports simultaneous use of different backends.

Note that some caging technologies may need to do specific actions upon cage entry and/or exit.  Since 3i supports calling arbitrary code, one can use this to jump to cage technology specific routines to handle those aspects.  This means that things such as Wasmtime’s `VMContext` management, are implemented in the corresponding runtime layer (e.g., the Wasmtime adapter). These runtime hooks are exposed to 3i as C-ABI function pointers and registered in 3i’s global table, decoupling runtime details from 3i’s core logic.

### Wasm Implementation

Grate execution relies on a re-entry mechanism that bridges Wasm runtime contexts (e.g., Wasmtime instances) and 3i’s routing layer. 

Each Wasm module in Wasmtime has its own `VMContext`, which encapsulates all runtime state required for that instance’s execution. When 3i performs a cross-module call (e.g., from _cage A_ to a _grate B_), the currently executing context belongs to _A_, but 3i needs to load the latest runtime state of _B_ before re-entering _B_'s Wasm code. 

Another design difference in lind-wasm is that each thread within a cage is represented by a separate Wasmtime instance. These per-thread instances share the same host memory by importing a common memory object, which enables in-process shared memory between threads. Each thread instance, however, maintains its own call stack. Because of this design, when storing runtime contexts we must uniquely identify them by both cage ID (`cageid`) and thread ID (`tid`). Most system calls can execute using the main-thread instance (`threadid = 0`), since they do not depend on per-thread stack state. However, calls such as `fork()`, which must capture or replicate the current thread’s execution stack, require referring to the precise thread-specific instance. To handle concurrent requests, lind-wasm maintains a small instance pool for the main-thread context: instead of a single threadid = 0 instance, we pre-allocate around ten clones that share the same memory but have separate stacks. This allows multiple inbound grate requests to execute in parallel without blocking on a single Wasm context.

Considering the two scenarios mentioned above, we need to store `VMContext` per `(cageid, threadid)` in order to re-enter and execute code logic of the Wasm module in grate calls. Because Rust’s lifetime system prevents us from directly sharing or globally storing references to the caller’s runtime structures, we instead store and pass raw pointers to the target module’s `VMContext`. 3i uses a registered callback function pointer, which contains execution logic of re-enter the Wasm module, and retrived the corresponding runtime context (`VMContext`) from pointer, which is used in callback function to re-enter a specific Wasm module. This allows 3i to reconstruct the correct execution environment for _B_ at re-entry time, ensuring cross-instance transitions without violating Rust’s ownership and lifetime rules.

During module initialization, Wasmtime captures each instance’s low-level `VMContext`. However, the registration of interposition handlers (`register_handler`) often occurs after initialization. To bridge this timing gap, Wasmtime maintains a runtime-local table:

```rust
GRATE_FN_WASM_TABLE: HashMap<(u64, u64), Box<GrateFnEntry>>
```

- Key: `(cageid, threadid)` -- cage and its thread identifiers
- Value: `Box<GrateFnEntry>` -- heap-allocated entry containing callback and necessary context pointers

When the user’s Wasm code calls `register_handler`, the entry is extracted and passed to 3i, and 3i stores (1) syscalls jump end point information in `HANDLERTABLE` and (2) execution logic (`(cageid, threadid)` with `GrateFnEntry`) in `GLOBAL_GRATE`.

```rust
GLOBAL_GRATE: Lazy<RwLock<HashMap<(u64, u64), Arc<GrateFnEntry>>>> =
    Lazy::new(|| RwLock::new(HashMap::new()));
```

- Key: `(cageid, threadid)` -- cage and its thread identifiers
- Value: `Arc<GrateFnEntry>` -- reference-counted entry that contains the callback function pointer and the associated `VMContext` pointer for re-entering the corresponding Wasm instance

#### Core Data Structures

**`VmCtxWrapper`**

A minimal wrapper around a non-null pointer to a Wasmtime `VMContext`. It allows the context pointer to be passed between Wasmtime and 3i without exposing the raw pointer across the codebase.

**`WasmCallbackCtx`**

Represents a single cage or grate execution context, storing:

- The cage identifier (cageid)
- The wrapped `VMContext` pointer

Each `WasmCallbackCtx` instance corresponds to one runtime environment capable of re-entering the correct Wasm instance during cross-cage invocation.

**`GrateFnEntry`**

Represents a single Grate function entry shared between the lind-3i crate in wasmtime and 3i.

|   Field      |         Type       |                             Functionality Description                                | 
|--------------|--------------------|-----------------------------------------------------------------------------------|
|   `fn_ptr`   |  `*const c_void`   | A C-ABI callback function pointer that re-enters the target Wasm module. This is used to jump back into the appropriate call-stack when the system call returns      |
|   `ctx_ptr`  | `*const VMContext` | Pointer to the instance’s runtime context required by Wasmtime during re-entry    |

`GrateFnEntry` instances are heap-allocated and referenced by 3i through stable raw pointers.

#### Execution Flow

**Callback Definition (Wasmtime side):**

The C-ABI callback function knows how to re-enter the Wasm module via the unified entry function.

**Context Staging:**

Wasmtime captures the instance’s `VMContext` and stores both the callback and context pointers in the `GRATE_FN_WASM_TABLE`.

**Handler Registration:**

1. When the Wasm module calls `register_handler()`, the staging entry is extracted and passed to 3i.
2. 3i associates the provided function/context pair with a specific `(cageid, tid)` in its handler table in 3i.

**Cross-Cage Invocation:**

When a syscall from _cage A_ is routed to _grate B_:

1. the regular syscall reaches 3i via `make_syscall`
2. 3i looks up the `(cageid, tid)` entry for B.
3. 3i retrieves the stored function pointer and `VMContext`.
4. 3i directly invokes the function pointer, re-entering the target Wasm instance through Wasmtime’s runtime context.

**Dispatch Inside Grate:**

The Wasm entry function (in module) receives a pointer identifying the target handler and dispatches control to the correct per-syscall implementation.
