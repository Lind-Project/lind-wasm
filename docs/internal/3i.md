# 3i and Grates

## ThreeI

3i (Three-I) provides the inter-cage interposition interface. This is a mechanism through which system calls and other inter-cage calls are routed within the Lind architecture.

It enables **call customization**, **system-call filtering**, and **fine-grained interpostion** without modifying the source code of either the kernel or the microvisor. Each cage and grate maintains its own system call table with customized jump endpoints, allowing flexible interception and redirection of calls at runtime.

### Motivation

In a traditional Linux environment, extending or intercepting system calls (e.g., adding a new filesystem, tracing, or filtering calls) requires kernel modifications or mechanisms such as ptrace, which incur heavy overhead and depend on kernel-level mediation.

3i eliminates these constraints by introducing a user-space routing layer between cages, grates, and the underlying microvisor. Calls can be dispatched directly between grates or delegated to the microvisor when necessary, achieving kernel-level extensibility while keeping all new logic external to the kernel’s TCB.

### 3i Function Calls 

|           Caller           |       Callee     |           Function            |  Interposable | Remarks |
|----------------------------|------------------|-------------------------------|---------------|---------------|
|   WASM / NaCl / RawPOSIX   |         3i       | `trigger_harsh_cage_exit`     |      No       |See detailed explaination below|
|         3i / grate         | grate / RawPOSIX | `harsh_cage_exit`             |      Yes      |See detailed explaination below|
|           grate            |         3i       | `register_handler`            |      Yes      |Register new handler information to scall table|
|           grate            |         3i       | `copy_handler_table_to_cage`  |      Yes      |Passes the handler table to the target cage|
|           grate            |         3i       | `copy_data_between_cages`     |      Yes      |Copies memory across cages|
|           grate            |         3i       | `make_syscall`                |      No       |Route the call to the corresponding handler and deal with error situations|

*NOTE: Interposable in the table means whether these calls are made via the system call table and thus whether or not a grate could alter their behavior*

#### `trigger_harsh_cage_exit` and `harsh_cage_exit`  

`trigger_harsh_cage_exit` is triggered by the caging or signaling infrastructure to indicate that a cage will (uncleanly) exit. After receiving notification, 3i will cleanup the 3i data structure (which is the system call table) and then 3i will go through the respective grates until reaching 3i's version of the call by triggering `harsh_cage_exit`. This call can be thought of as notifying the grates and microvisor of the harsh exit of a program whose memory state cannot be relied upon. This is unlike the `exit_syscall`, which is performed by a functioning program with intact memory as part of its termination.. 

## Grates

### Overview

Grates are privileged cages that provide services to descendant cages by interposing on their system calls. They can execute trusted operations (e.g., syscall filtering, tracing, or in-memory file I/O) on behalf of other cages without requiring changes to the microvisor’s trusted computing base (TCB).

From 3i’s perspective, a grate is both:

- A consumer of system calls from descendant cages, and
- A service provider exposing its own callable entry points to the 3i runtime.

Grate execution relies on a re-entry mechanism that bridges Wasm runtime contexts (e.g., Wasmtime instances) and 3i’s routing layer.
When 3i dispatches a syscall from _cage A_ to a _grate B_, it uses a registered callback function pointer and its corresponding runtime context (`VMContext`) to re-enter the target Wasm instance.

### Design Goals

3i’s public API is runtime-agnostic, allowing it to be adapted to multiple backends (e.g., Wasmtime, MPK, or future runtimes).

untime-specific mechanisms, such as Wasmtime’s VMContext management, are implemented in the corresponding runtime layer (e.g., the Wasmtime adapter). These runtime hooks are exposed to 3i as C-ABI function pointers and registered in 3i’s global table, decoupling runtime details from 3i’s core logic.

All function pointers and runtime context structures are heap-allocated to avoid reliance on Rust closures, ensuring consistent cross-boundary behavior between the runtime and 3i.

### Implementation

During module initialization, Wasmtime captures each instance’s low-level `VMContext`, representing its active execution state (memories, globals, tables, etc.). However, the registration of interposition handlers (`register_handler`) often occurs after initialization. To bridge this timing gap, Wasmtime maintains a runtime-local staging table:

```rust
GRATE_FN_WASM_TABLE: HashMap<(u64, u64), Box<GrateFnEntry>>
```

- Key: `(pid, tid)` -- process and thread identifiers
- Value: `Box<GrateFnEntry>` -- stable heap-allocated entry containing callback and necessary context pointers

When the user’s Wasm code calls `register_handler`, the staging entry is extracted and passed to 3i, where it becomes the canonical reference for that `(pid, tid)` pair.

_Note: `tid = 0` is currently used as a placeholder; multi-thread support will be added in future revisions._

#### Core Data Structures

**`VmCtxWrapper`**

A minimal wrapper around a non-null pointer to a Wasmtime `VMContext`. It allows the context pointer to be passed between Wasmtime and 3i without exposing the raw pointer across the codebase.

**`WasmCallbackCtx`**

Represents a single cage or grate execution context, storing:

- The process identifier (pid)
- The wrapped VMContext pointer

Each `WasmCallbackCtx` instance corresponds to one runtime environment capable of re-entering the correct Wasm instance during cross-cage invocation.

**`GrateFnEntry`**

Represents a single Grate function entry shared between the lind-3i crate in wasmtime and 3i.

|   Field      |         Type       |                             FunDescriptionction                                   | 
|--------------|--------------------|-----------------------------------------------------------------------------------|
|   `fn_ptr`   |  `*const c_void`   | A C-ABI callback function pointer that re-enters the target Wasm module           |
|   `ctx_ptr`  | `*const VMContext` | Pointer to the instance’s runtime context required by Wasmtime during re-entry    |

`GrateFnEntry` instances are heap-allocated and referenced by 3i through stable raw pointers.

#### Execution Flow

**Callback Definition (Wasmtime side):**

The C-ABI callback function knows how to re-enter the Wasm module via the unified entry function.

**Context Staging:**

Wasmtime captures the instance’s `VMContext` and stores both the callback and context pointers in the `GRATE_FN_WASM_TABLE`.

**Handler Registration:**

1. When the Wasm module calls `register_handler()`, the staging entry is extracted and passed to 3i.
2. 3i associates the provided function/context pair with a specific `(pid, tid)` in its handler table in 3i.

**Cross-Cage Invocation:**

When a syscall from _cage A_ is routed to _grate B_:

1. the regular syscall reaches 3i via `make_syscall`
2. 3i looks up the `(pid, tid)` entry for B.
3. 3i retrieves the stored function pointer and `VMContext`.
4. 3i directly invokes the function pointer, re-entering the target Wasm instance through Wasmtime’s runtime context.

**Dispatch Inside Grate:**

The Wasm entry function (in module) receives a pointer identifying the target handler and dispatches control to the correct per-syscall implementation.
